<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K2 Defense â€” Space Shooter</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸš€</text></svg>">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            color: #e8e8ed;
            font-family: 'Courier New', monospace;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-x: hidden;
            image-rendering: pixelated;
        }
        .game-header {
            width: 100%;
            max-width: 800px;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .game-header h1 { font-size: 1.5rem; color: #4a9eff; }
        .game-header a { color: #9898a8; text-decoration: none; font-size: 0.9rem; }
        .game-header a:hover { color: #e8e8ed; }
        .game-container {
            position: relative;
            border: 3px solid #2a2a38;
            border-radius: 4px;
            overflow: hidden;
            box-shadow: 0 0 40px rgba(74, 158, 255, 0.2);
        }
        #gameCanvas { display: block; background: #000; image-rendering: pixelated; }
        .game-ui {
            position: absolute;
            top: 8px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            text-shadow: 2px 2px 0px #000;
            pointer-events: none;
        }
        .score { color: #4aff8c; }
        .lives { color: #ff6b4a; }
        .level { color: #4a9eff; }
        .powerup-indicator {
            position: absolute;
            bottom: 8px;
            left: 10px;
            display: flex;
            gap: 8px;
            pointer-events: none;
        }
        .powerup-badge {
            background: rgba(0,0,0,0.8);
            padding: 4px 8px;
            border: 1px solid #4a9eff;
            font-size: 10px;
            display: none;
        }
        .powerup-badge.active { display: block; }
        .overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.92);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
        }
        .overlay.hidden { display: none; }
        .overlay h2 { font-size: 2rem; margin-bottom: 20px; color: #4a9eff; text-shadow: 0 0 10px #4a9eff; }
        .overlay p { color: #9898a8; margin-bottom: 8px; font-size: 14px; }
        .overlay .final-score { font-size: 2.5rem; color: #4aff8c; margin: 15px 0; text-shadow: 0 0 10px #4aff8c; }
        .overlay button {
            background: #4a9eff;
            color: #000;
            border: none;
            padding: 12px 32px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            margin-top: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .overlay button:hover { background: #6ab0ff; }
        .controls { margin-top: 10px; font-size: 12px; color: #666; }
        .level-announce {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            font-weight: bold;
            color: #4a9eff;
            text-shadow: 0 0 20px #4a9eff, 0 0 40px #4a9eff;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            letter-spacing: 4px;
        }
        .level-announce.show { opacity: 1; }
        .leaderboard {
            width: 100%;
            max-width: 800px;
            padding: 20px;
            margin-top: 20px;
        }
        .leaderboard h3 { color: #4a9eff; margin-bottom: 15px; font-size: 14px; letter-spacing: 2px; }
        .leaderboard-list {
            background: #0a0a0f;
            border: 2px solid #2a2a38;
            overflow: hidden;
        }
        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            padding: 10px 15px;
            border-bottom: 1px solid #1a1a24;
            font-size: 12px;
        }
        .leaderboard-entry:last-child { border-bottom: none; }
        .rank { color: #9898a8; width: 40px; }
        .rank.gold { color: #ffd700; }
        .rank.silver { color: #c0c0c0; }
        .rank.bronze { color: #cd7f32; }
        .name { flex: 1; color: #e8e8ed; }
        .entry-score { color: #4aff8c; }
        .mobile-controls {
            display: none;
            width: 100%;
            max-width: 400px;
            padding: 10px;
        }
        .mobile-row { display: flex; justify-content: center; gap: 5px; margin: 5px 0; }
        .mobile-btn {
            width: 60px;
            height: 60px;
            font-size: 1.5rem;
            background: #1a1a24;
            border: 2px solid #2a2a38;
            color: #e8e8ed;
            cursor: pointer;
            user-select: none;
        }
        .mobile-btn:active { background: #2a2a38; border-color: #4a9eff; }
        .fire-btn { width: 130px; background: #4a9eff; color: #000; }
        .sound-toggle {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(0,0,0,0.7);
            border: 1px solid #2a2a38;
            color: #e8e8ed;
            padding: 6px 10px;
            cursor: pointer;
            font-size: 16px;
            z-index: 100;
        }
        @media (max-width: 850px) {
            .mobile-controls { display: block; }
        }
    </style>
</head>
<body>
    <div class="game-header">
        <h1>>>> K2 DEFENSE</h1>
        <a href="index.html">[ BACK ]</a>
    </div>

    <div class="game-container">
        <canvas id="gameCanvas" width="600" height="700"></canvas>
        <button class="sound-toggle" id="soundToggle">â™ª</button>
        
        <div class="game-ui">
            <div class="score">SCORE:<span id="scoreDisplay">000000</span></div>
            <div class="level">LEVEL:<span id="levelDisplay">01</span></div>
            <div class="lives">SHIPS:<span id="livesDisplay">|||</span></div>
        </div>

        <div class="powerup-indicator">
            <div class="powerup-badge" id="shieldBadge">SHIELD</div>
            <div class="powerup-badge" id="rapidBadge">RAPID</div>
            <div class="powerup-badge" id="spreadBadge">SPREAD</div>
        </div>

        <div class="level-announce" id="levelAnnounce">LEVEL 01</div>

        <div id="startOverlay" class="overlay">
            <h2>K2 DEFENSE</h2>
            <p>IMPERIAL FORCES APPROACHING</p>
            <p>DEFEND THE SECTOR</p>
            <div class="controls">
                <p>ARROWS / WASD - MOVE</p>
                <p>SPACE - FIRE</p>
            </div>
            <button id="startBtn">START MISSION</button>
        </div>

        <div id="gameOverOverlay" class="overlay hidden">
            <h2>MISSION FAILED</h2>
            <p>LEVEL <span id="finalLevel">01</span> REACHED</p>
            <div class="final-score" id="finalScore">000000</div>
            <p id="newHighScore" style="color: #ffd700; display: none;">* NEW HIGH SCORE *</p>
            <input type="text" id="nameInput" placeholder="CALLSIGN" maxlength="8" 
                   style="padding: 8px 15px; font-size: 14px; border: 2px solid #4a9eff; 
                          background: #000; color: #4aff8c; text-align: center; margin-top: 10px; 
                          display: none; font-family: 'Courier New', monospace; text-transform: uppercase;">
            <button id="restartBtn">RETRY</button>
        </div>
    </div>

    <div class="mobile-controls">
        <div class="mobile-row">
            <button class="mobile-btn" id="upBtn">â–²</button>
        </div>
        <div class="mobile-row">
            <button class="mobile-btn" id="leftBtn">â—„</button>
            <button class="mobile-btn" id="downBtn">â–¼</button>
            <button class="mobile-btn" id="rightBtn">â–º</button>
        </div>
        <div class="mobile-row">
            <button class="mobile-btn fire-btn" id="fireBtn">FIRE</button>
        </div>
    </div>

    <div class="leaderboard">
        <h3>/// TOP PILOTS ///</h3>
        <div class="leaderboard-list" id="leaderboardList"></div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;

        // ===== AUDIO =====
        let audioCtx = null;
        let soundEnabled = true;

        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }

        function playSound(type) {
            if (!soundEnabled || !audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            switch(type) {
                case 'shoot':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(880, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(220, audioCtx.currentTime + 0.08);
                    gain.gain.setValueAtTime(0.08, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.08);
                    osc.start(); osc.stop(audioCtx.currentTime + 0.08);
                    break;
                case 'explosion':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(200, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.2);
                    gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    osc.start(); osc.stop(audioCtx.currentTime + 0.2);
                    break;
                case 'playerHit':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(30, audioCtx.currentTime + 0.4);
                    gain.gain.setValueAtTime(0.25, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
                    osc.start(); osc.stop(audioCtx.currentTime + 0.4);
                    break;
                case 'powerup':
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(440, audioCtx.currentTime);
                    osc.frequency.setValueAtTime(660, audioCtx.currentTime + 0.05);
                    osc.frequency.setValueAtTime(880, audioCtx.currentTime + 0.1);
                    gain.gain.setValueAtTime(0.12, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    osc.start(); osc.stop(audioCtx.currentTime + 0.2);
                    break;
                case 'levelUp':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(523, audioCtx.currentTime);
                    osc.frequency.setValueAtTime(659, audioCtx.currentTime + 0.08);
                    osc.frequency.setValueAtTime(784, audioCtx.currentTime + 0.16);
                    osc.frequency.setValueAtTime(1047, audioCtx.currentTime + 0.24);
                    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
                    osc.start(); osc.stop(audioCtx.currentTime + 0.4);
                    break;
                case 'warp':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(80, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(2000, audioCtx.currentTime + 0.8);
                    gain.gain.setValueAtTime(0.12, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1);
                    osc.start(); osc.stop(audioCtx.currentTime + 1);
                    break;
            }
        }

        document.getElementById('soundToggle').addEventListener('click', () => {
            soundEnabled = !soundEnabled;
            document.getElementById('soundToggle').textContent = soundEnabled ? 'â™ª' : 'Ã—';
        });

        // ===== GAME STATE =====
        let gameRunning = false;
        let score = 0;
        let lives = 3;
        let level = 1;
        let gameLoop;
        let invincible = false;
        let invincibleTimer = 0;
        let waveTransition = false;
        let enemiesSpawned = 0;
        let enemiesRequired = 10;
        let spawnTimer = 0;
        let frameCount = 0;

        // Warp effect state
        let inWarp = false;
        let warpProgress = 0;
        let warpStars = [];

        // Environment system
        const environments = [
            { name: 'Deep Space', bg: '#000008', starColor: '#fff', nebulaColor: null, hasAsteroids: false, hasPlanets: true },
            { name: 'Asteroid Field', bg: '#0a0806', starColor: '#ffddaa', nebulaColor: null, hasAsteroids: true, hasPlanets: false },
            { name: 'Nebula', bg: '#080012', starColor: '#ff88ff', nebulaColor: 'rgba(100, 50, 150, 0.15)', hasAsteroids: false, hasPlanets: true },
            { name: 'Gas Giant', bg: '#041008', starColor: '#aaffaa', nebulaColor: 'rgba(50, 150, 100, 0.1)', hasAsteroids: false, hasPlanets: true },
            { name: 'Binary Star', bg: '#0a0400', starColor: '#ffaa44', nebulaColor: 'rgba(150, 100, 50, 0.08)', hasAsteroids: true, hasPlanets: false },
        ];
        let currentEnv = environments[0];

        // Background objects
        let bgObjects = []; // Planets, asteroids, distant objects
        let asteroids = [];

        // Power-ups
        let powerups = { shield: { active: false, timer: 0 }, rapid: { active: false, timer: 0 }, spread: { active: false, timer: 0 } };
        let shootCooldown = 0;

        // Player
        const player = { x: 300, y: 580, speed: 4, engineFrame: 0 };

        // Arrays
        let bullets = [];
        let enemies = [];
        let particles = [];
        let stars = [];
        let powerupItems = [];
        let enemyBullets = [];

        const keys = {};

        // ===== ENHANCED PIXEL ART =====
        
        // X-wing with animated engines
        function drawPlayer() {
            if (!gameRunning && !inWarp) return;
            ctx.save();
            ctx.translate(Math.floor(player.x), Math.floor(player.y));

            if (invincible && Math.floor(Date.now() / 80) % 2 === 0) ctx.globalAlpha = 0.4;

            // Shield effect
            if (powerups.shield.active) {
                ctx.strokeStyle = '#4a9eff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, 24, 0, Math.PI * 2);
                ctx.stroke();
                ctx.strokeStyle = 'rgba(74, 158, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(0, 0, 26, 0, Math.PI * 2);
                ctx.stroke();
            }

            const px = 2; // pixel size

            // ===== X-WING SPRITE (Enhanced) =====
            // Fuselage (main body)
            ctx.fillStyle = '#d8d8e8';
            ctx.fillRect(-1*px, -7*px, 2*px, 12*px);
            ctx.fillRect(-2*px, -5*px, 4*px, 8*px);
            
            // Fuselage details
            ctx.fillStyle = '#a0a0b0';
            ctx.fillRect(-2*px, 1*px, 4*px, 2*px);
            
            // Nose cone (red tip)
            ctx.fillStyle = '#ff5544';
            ctx.fillRect(-1*px, -9*px, 2*px, 2*px);
            ctx.fillStyle = '#cc3322';
            ctx.fillRect(0, -10*px, 1*px, 1*px);
            
            // Cockpit (blue canopy)
            ctx.fillStyle = '#3388ff';
            ctx.fillRect(-1*px, -5*px, 2*px, 3*px);
            ctx.fillStyle = '#55aaff';
            ctx.fillRect(-1*px, -5*px, 1*px, 2*px);
            
            // ===== S-FOILS (Wings in attack position) =====
            ctx.fillStyle = '#c0c0d0';
            // Upper left wing
            ctx.fillRect(-9*px, -4*px, 7*px, 1*px);
            ctx.fillRect(-10*px, -3*px, 8*px, 1*px);
            ctx.fillRect(-9*px, -2*px, 7*px, 1*px);
            // Upper right wing
            ctx.fillRect(2*px, -4*px, 7*px, 1*px);
            ctx.fillRect(2*px, -3*px, 8*px, 1*px);
            ctx.fillRect(2*px, -2*px, 7*px, 1*px);
            // Lower left wing
            ctx.fillRect(-9*px, 1*px, 7*px, 1*px);
            ctx.fillRect(-10*px, 2*px, 8*px, 1*px);
            ctx.fillRect(-9*px, 3*px, 7*px, 1*px);
            // Lower right wing
            ctx.fillRect(2*px, 1*px, 7*px, 1*px);
            ctx.fillRect(2*px, 2*px, 8*px, 1*px);
            ctx.fillRect(2*px, 3*px, 7*px, 1*px);
            
            // Wing struts
            ctx.fillStyle = '#909098';
            ctx.fillRect(-4*px, -3*px, 2*px, 1*px);
            ctx.fillRect(2*px, -3*px, 2*px, 1*px);
            ctx.fillRect(-4*px, 2*px, 2*px, 1*px);
            ctx.fillRect(2*px, 2*px, 2*px, 1*px);
            
            // Laser cannons (wing tips - red)
            ctx.fillStyle = '#ff4433';
            ctx.fillRect(-11*px, -5*px, 2*px, 3*px);
            ctx.fillRect(9*px, -5*px, 2*px, 3*px);
            ctx.fillRect(-11*px, 1*px, 2*px, 3*px);
            ctx.fillRect(9*px, 1*px, 2*px, 3*px);
            
            // ===== ANIMATED ENGINES =====
            player.engineFrame = (player.engineFrame + 0.3) % 4;
            const engineLength = 3 + Math.floor(player.engineFrame);
            const engineBright = powerups.rapid.active;
            
            // Main engines (4 engines on X-wing)
            const engineColor = engineBright ? '#ffdd44' : '#44ff88';
            const engineGlow = engineBright ? '#ff8800' : '#22aa55';
            
            ctx.fillStyle = engineGlow;
            ctx.fillRect(-2*px, 5*px, 1*px, engineLength*px);
            ctx.fillRect(1*px, 5*px, 1*px, engineLength*px);
            
            ctx.fillStyle = engineColor;
            ctx.fillRect(-2*px, 5*px, 1*px, (engineLength-1)*px);
            ctx.fillRect(1*px, 5*px, 1*px, (engineLength-1)*px);
            
            // Engine exhaust particles (when moving)
            if (keys['ArrowUp'] || keys['w'] || keys['W']) {
                ctx.fillStyle = engineBright ? '#ffaa00' : '#88ffaa';
                for (let i = 0; i < 3; i++) {
                    const py = 7*px + Math.random() * 6;
                    const pxOff = (Math.random() - 0.5) * 4;
                    ctx.fillRect(-1.5*px + pxOff, py, 1*px, 2*px);
                    ctx.fillRect(0.5*px + pxOff, py, 1*px, 2*px);
                }
            }

            ctx.restore();
        }

        // Enhanced TIE Fighter
        function drawEnemy(enemy) {
            ctx.save();
            ctx.translate(Math.floor(enemy.x), Math.floor(enemy.y));

            const px = 2;
            const isBoss = enemy.type === 'boss';
            const isElite = enemy.type === 'elite';
            
            if (isBoss) ctx.scale(1.8, 1.8);

            // ===== TIE FIGHTER SPRITE =====
            // Center cockpit ball
            ctx.fillStyle = isBoss ? '#552222' : '#404050';
            ctx.fillRect(-3*px, -3*px, 6*px, 6*px);
            ctx.fillRect(-2*px, -4*px, 4*px, 8*px);
            ctx.fillRect(-4*px, -2*px, 8*px, 4*px);
            
            // Viewport window
            ctx.fillStyle = isBoss ? '#ff3333' : isElite ? '#ffdd00' : '#4488ff';
            ctx.fillRect(-2*px, -2*px, 4*px, 4*px);
            ctx.fillStyle = isBoss ? '#ff6666' : isElite ? '#ffff44' : '#66aaff';
            ctx.fillRect(-1*px, -1*px, 2*px, 2*px);
            
            // Wing pylons
            ctx.fillStyle = isBoss ? '#331111' : '#303038';
            ctx.fillRect(-5*px, -1*px, 1*px, 2*px);
            ctx.fillRect(4*px, -1*px, 1*px, 2*px);
            
            // ===== HEXAGONAL SOLAR PANELS =====
            ctx.fillStyle = isBoss ? '#441111' : '#282830';
            // Left panel
            ctx.fillRect(-8*px, -5*px, 2*px, 10*px);
            ctx.fillRect(-9*px, -4*px, 3*px, 8*px);
            ctx.fillRect(-10*px, -3*px, 4*px, 6*px);
            // Right panel
            ctx.fillRect(6*px, -5*px, 2*px, 10*px);
            ctx.fillRect(6*px, -4*px, 3*px, 8*px);
            ctx.fillRect(6*px, -3*px, 4*px, 6*px);
            
            // Panel struts (vertical lines)
            ctx.fillStyle = isBoss ? '#552222' : '#383840';
            ctx.fillRect(-9*px, -4*px, 1*px, 8*px);
            ctx.fillRect(-7*px, -5*px, 1*px, 10*px);
            ctx.fillRect(6*px, -5*px, 1*px, 10*px);
            ctx.fillRect(8*px, -4*px, 1*px, 8*px);

            // Boss health bar
            if (isBoss) {
                ctx.fillStyle = '#222';
                ctx.fillRect(-10*px, -9*px, 20*px, 3*px);
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(-10*px, -9*px, 20*px * (enemy.health / enemy.maxHealth), 3*px);
            }

            ctx.restore();
        }

        // Power-up drawing with glow
        function drawPowerup(p) {
            ctx.save();
            ctx.translate(Math.floor(p.x), Math.floor(p.y));
            
            const px = 2;
            const pulse = Math.sin(Date.now() / 150) * 0.3 + 0.7;
            
            // Glow effect
            ctx.globalAlpha = pulse * 0.3;
            ctx.fillStyle = p.color;
            ctx.fillRect(-5*px, -5*px, 10*px, 10*px);
            
            ctx.globalAlpha = pulse;
            ctx.fillStyle = p.color;
            ctx.fillRect(-3*px, -3*px, 6*px, 6*px);
            ctx.fillStyle = '#fff';
            ctx.fillRect(-2*px, -2*px, 4*px, 4*px);
            ctx.fillStyle = p.color;
            ctx.fillRect(-1*px, -1*px, 2*px, 2*px);
            
            // Icon based on type
            ctx.fillStyle = '#000';
            if (p.type === 'shield') {
                ctx.fillRect(-1*px, -2*px, 2*px, 1*px);
                ctx.fillRect(-2*px, -1*px, 4*px, 2*px);
                ctx.fillRect(-1*px, 1*px, 2*px, 1*px);
            } else if (p.type === 'rapid') {
                ctx.fillRect(0, -2*px, 1*px, 4*px);
                ctx.fillRect(-1*px, 0, 3*px, 1*px);
            } else if (p.type === 'spread') {
                ctx.fillRect(-1*px, -1*px, 1*px, 2*px);
                ctx.fillRect(0, -1*px, 1*px, 2*px);
                ctx.fillRect(1*px, -1*px, 1*px, 2*px);
            }
            
            ctx.restore();
        }

        // ===== BACKGROUND SYSTEMS =====

        // Initialize stars for current environment
        function initStars() {
            stars = [];
            for (let i = 0; i < 100; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    speed: Math.random() * 2 + 0.5,
                    size: Math.random() < 0.2 ? 2 : 1,
                    bright: Math.random(),
                    twinkle: Math.random() * 100
                });
            }
        }

        // Initialize background objects based on environment
        function initBgObjects() {
            bgObjects = [];
            
            // Add planets for applicable environments
            if (currentEnv.hasPlanets) {
                // Distant planet
                bgObjects.push({
                    type: 'planet',
                    x: 100 + Math.random() * 400,
                    y: -200,
                    radius: 40 + Math.random() * 60,
                    color: ['#664422', '#446644', '#554466', '#665544'][Math.floor(Math.random() * 4)],
                    speed: 0.1 + Math.random() * 0.1
                });
            }
            
            // Asteroids for asteroid field
            asteroids = [];
            if (currentEnv.hasAsteroids) {
                for (let i = 0; i < 8; i++) {
                    spawnAsteroid(true);
                }
            }
        }

        function spawnAsteroid(initial = false) {
            asteroids.push({
                x: Math.random() * canvas.width,
                y: initial ? Math.random() * canvas.height : -30,
                size: 8 + Math.random() * 20,
                speed: 0.5 + Math.random() * 1.5,
                rotation: Math.random() * Math.PI * 2,
                rotSpeed: (Math.random() - 0.5) * 0.05,
                vertices: 5 + Math.floor(Math.random() * 4)
            });
        }

        function drawAsteroid(a) {
            ctx.save();
            ctx.translate(a.x, a.y);
            ctx.rotate(a.rotation);
            
            ctx.fillStyle = '#443322';
            ctx.strokeStyle = '#665544';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            for (let i = 0; i < a.vertices; i++) {
                const angle = (Math.PI * 2 / a.vertices) * i;
                const r = a.size * (0.7 + Math.random() * 0.3);
                const x = Math.cos(angle) * r;
                const y = Math.sin(angle) * r;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Crater detail
            ctx.fillStyle = '#332211';
            ctx.beginPath();
            ctx.arc(a.size * 0.2, a.size * 0.1, a.size * 0.2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }

        function drawPlanet(p) {
            ctx.save();
            
            // Planet shadow/gradient effect
            const gradient = ctx.createRadialGradient(
                p.x - p.radius * 0.3, p.y - p.radius * 0.3, 0,
                p.x, p.y, p.radius
            );
            gradient.addColorStop(0, p.color);
            gradient.addColorStop(0.7, p.color);
            gradient.addColorStop(1, '#111');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Atmosphere glow
            ctx.strokeStyle = 'rgba(100, 150, 255, 0.2)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius + 3, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.restore();
        }

        // ===== WARP EFFECT =====
        function initWarpStars() {
            warpStars = [];
            for (let i = 0; i < 150; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * 50 + 10;
                warpStars.push({
                    angle,
                    dist,
                    speed: Math.random() * 10 + 5,
                    length: 0
                });
            }
        }

        function drawWarpEffect() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            
            // Star streaks
            warpStars.forEach(star => {
                const startX = cx + Math.cos(star.angle) * star.dist;
                const startY = cy + Math.sin(star.angle) * star.dist;
                const endDist = star.dist + star.length;
                const endX = cx + Math.cos(star.angle) * endDist;
                const endY = cy + Math.sin(star.angle) * endDist;
                
                const gradient = ctx.createLinearGradient(startX, startY, endX, endY);
                gradient.addColorStop(0, 'rgba(255,255,255,0)');
                gradient.addColorStop(0.5, 'rgba(100,150,255,0.8)');
                gradient.addColorStop(1, 'rgba(255,255,255,1)');
                
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                
                // Update star
                star.dist += star.speed * (warpProgress / 100);
                star.length = Math.min(star.length + star.speed * 0.5, 200);
                
                // Reset if off screen
                if (star.dist > 500) {
                    star.dist = Math.random() * 50 + 10;
                    star.length = 0;
                }
            });
            
            // Central flash at peak
            if (warpProgress > 80) {
                const flashAlpha = (warpProgress - 80) / 20;
                ctx.fillStyle = `rgba(255,255,255,${flashAlpha})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        function startWarp(callback) {
            inWarp = true;
            warpProgress = 0;
            initWarpStars();
            playSound('warp');
            
            const warpLoop = () => {
                warpProgress += 2;
                drawWarpEffect();
                
                // Draw player during warp (centered, moving forward)
                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2 + 100 - warpProgress);
                player.engineFrame = (player.engineFrame + 0.5) % 4;
                
                const px = 2;
                // Simplified player during warp
                ctx.fillStyle = '#d8d8e8';
                ctx.fillRect(-1*px, -7*px, 2*px, 12*px);
                ctx.fillRect(-2*px, -5*px, 4*px, 8*px);
                ctx.fillStyle = '#ff5544';
                ctx.fillRect(-1*px, -9*px, 2*px, 2*px);
                ctx.fillStyle = '#3388ff';
                ctx.fillRect(-1*px, -5*px, 2*px, 3*px);
                
                // Wings
                ctx.fillStyle = '#c0c0d0';
                ctx.fillRect(-9*px, -3*px, 7*px, 1*px);
                ctx.fillRect(2*px, -3*px, 7*px, 1*px);
                ctx.fillRect(-9*px, 2*px, 7*px, 1*px);
                ctx.fillRect(2*px, 2*px, 7*px, 1*px);
                
                // Stretched engines during warp
                const engineLen = 5 + warpProgress / 10;
                ctx.fillStyle = '#44ff88';
                ctx.fillRect(-2*px, 5*px, 1*px, engineLen*px);
                ctx.fillRect(1*px, 5*px, 1*px, engineLen*px);
                
                ctx.restore();
                
                if (warpProgress < 100) {
                    requestAnimationFrame(warpLoop);
                } else {
                    inWarp = false;
                    callback();
                }
            };
            warpLoop();
        }

        // ===== GAME LOGIC =====

        function spawnEnemy() {
            const isElite = Math.random() < 0.08 * level;
            const isBoss = level % 5 === 0 && enemiesSpawned === enemiesRequired - 1;
            
            enemies.push({
                x: 50 + Math.random() * (canvas.width - 100),
                y: -30,
                dx: (Math.random() - 0.5) * 2,
                dy: 1 + level * 0.15 + Math.random() * 0.5,
                health: isBoss ? 15 + level * 3 : isElite ? 3 : 1,
                maxHealth: isBoss ? 15 + level * 3 : isElite ? 3 : 1,
                type: isBoss ? 'boss' : isElite ? 'elite' : 'normal',
                shootTimer: 60 + Math.random() * 60
            });
            enemiesSpawned++;
        }

        function shoot() {
            if (shootCooldown > 0) return;
            playSound('shoot');
            shootCooldown = powerups.rapid.active ? 6 : 14;

            if (powerups.spread.active) {
                [-15, 0, 15].forEach(angle => {
                    const rad = angle * Math.PI / 180;
                    bullets.push({ x: player.x, y: player.y - 15, dx: Math.sin(rad) * 4, dy: -10 });
                });
            } else {
                // Fire from wing cannons
                bullets.push({ x: player.x - 18, y: player.y - 8, dx: 0, dy: -10 });
                bullets.push({ x: player.x + 18, y: player.y - 8, dx: 0, dy: -10 });
            }
        }

        function enemyShoot(enemy) {
            const speed = 3 + level * 0.2;
            enemyBullets.push({ x: enemy.x, y: enemy.y + 15, dy: speed, dx: 0 });
            if (enemy.type === 'boss') {
                enemyBullets.push({ x: enemy.x - 15, y: enemy.y + 10, dy: speed, dx: -0.5 });
                enemyBullets.push({ x: enemy.x + 15, y: enemy.y + 10, dy: speed, dx: 0.5 });
            }
        }

        function spawnPowerup(x, y) {
            if (Math.random() > 0.12) return;
            const types = [
                { type: 'shield', color: '#4a9eff' },
                { type: 'rapid', color: '#ffd700' },
                { type: 'spread', color: '#ff6b4a' },
                { type: 'life', color: '#ff4a8c' }
            ];
            powerupItems.push({ x, y, dy: 2, ...types[Math.floor(Math.random() * types.length)] });
        }

        function explode(x, y, color = '#ff6b4a', count = 8) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 / count) * i + Math.random() * 0.5;
                const speed = Math.random() * 3 + 1;
                particles.push({
                    x, y,
                    dx: Math.cos(angle) * speed,
                    dy: Math.sin(angle) * speed,
                    size: Math.floor(Math.random() * 3) + 2,
                    color,
                    life: 20 + Math.random() * 15
                });
            }
        }

        function playerExplode() {
            playSound('playerHit');
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 1;
                const colors = ['#ff6b4a', '#ffd700', '#4a9eff', '#fff', '#ff5544'];
                particles.push({
                    x: player.x, y: player.y,
                    dx: Math.cos(angle) * speed,
                    dy: Math.sin(angle) * speed,
                    size: Math.floor(Math.random() * 4) + 2,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    life: 30 + Math.random() * 25
                });
            }
        }

        function announceLevel() {
            const el = document.getElementById('levelAnnounce');
            el.textContent = level % 5 === 0 ? `BOSS LVL ${String(level).padStart(2, '0')}` : `LEVEL ${String(level).padStart(2, '0')}`;
            el.classList.add('show');
            playSound('levelUp');
            setTimeout(() => el.classList.remove('show'), 2000);
        }

        function changeEnvironment() {
            currentEnv = environments[(level - 1) % environments.length];
            initBgObjects();
        }

        function update() {
            frameCount++;
            if (shootCooldown > 0) shootCooldown--;
            
            if (invincible) {
                invincibleTimer--;
                if (invincibleTimer <= 0) invincible = false;
            }

            Object.keys(powerups).forEach(key => {
                if (powerups[key].active) {
                    powerups[key].timer--;
                    if (powerups[key].timer <= 0) {
                        powerups[key].active = false;
                        document.getElementById(key + 'Badge').classList.remove('active');
                    }
                }
            });

            // Player movement (4-way)
            let dx = 0, dy = 0;
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) dx = -player.speed;
            if (keys['ArrowRight'] || keys['d'] || keys['D']) dx = player.speed;
            if (keys['ArrowUp'] || keys['w'] || keys['W']) dy = -player.speed;
            if (keys['ArrowDown'] || keys['s'] || keys['S']) dy = player.speed;
            
            player.x = Math.max(30, Math.min(canvas.width - 30, player.x + dx));
            player.y = Math.max(100, Math.min(canvas.height - 30, player.y + dy));

            // Stars
            stars.forEach(star => {
                star.y += star.speed * (1 + level * 0.05);
                star.twinkle += 0.1;
                if (star.y > canvas.height) { star.y = 0; star.x = Math.random() * canvas.width; }
            });

            // Background objects
            bgObjects.forEach(obj => {
                if (obj.type === 'planet') {
                    obj.y += obj.speed;
                    if (obj.y > canvas.height + obj.radius * 2) {
                        obj.y = -obj.radius * 2 - 100;
                        obj.x = 50 + Math.random() * (canvas.width - 100);
                    }
                }
            });

            // Asteroids
            asteroids.forEach(a => {
                a.y += a.speed;
                a.rotation += a.rotSpeed;
            });
            asteroids = asteroids.filter(a => a.y < canvas.height + a.size);
            if (currentEnv.hasAsteroids && asteroids.length < 8 && Math.random() < 0.02) {
                spawnAsteroid();
            }

            // Spawn enemies (scrolling style)
            if (!waveTransition && enemiesSpawned < enemiesRequired) {
                spawnTimer--;
                if (spawnTimer <= 0) {
                    spawnEnemy();
                    spawnTimer = Math.max(20, 60 - level * 3);
                }
            }

            // Bullets
            bullets = bullets.filter(b => {
                b.x += b.dx || 0;
                b.y += b.dy;
                return b.y > 0 && b.y < canvas.height && b.x > 0 && b.x < canvas.width;
            });

            enemyBullets = enemyBullets.filter(b => {
                b.x += b.dx || 0;
                b.y += b.dy;
                return b.y < canvas.height + 20;
            });

            // Enemies
            enemies.forEach(enemy => {
                enemy.x += enemy.dx;
                enemy.y += enemy.dy;
                
                // Bounce off walls
                if (enemy.x < 30 || enemy.x > canvas.width - 30) enemy.dx *= -1;
                
                // Shooting
                enemy.shootTimer--;
                if (enemy.shootTimer <= 0 && enemy.y > 50 && enemy.y < canvas.height - 200) {
                    if (Math.random() < 0.4) enemyShoot(enemy);
                    enemy.shootTimer = enemy.type === 'boss' ? 30 : 80;
                }
            });

            // Remove enemies that went off screen
            enemies = enemies.filter(e => e.y < canvas.height + 50);

            // Power-ups
            powerupItems = powerupItems.filter(p => { p.y += p.dy; return p.y < canvas.height; });

            // Particles
            particles = particles.filter(p => { p.x += p.dx; p.y += p.dy; p.life--; return p.life > 0; });

            // Bullet-enemy collision
            bullets.forEach((bullet, bi) => {
                enemies.forEach((enemy, ei) => {
                    const hitDist = enemy.type === 'boss' ? 25 : 16;
                    if (Math.abs(bullet.x - enemy.x) < hitDist && Math.abs(bullet.y - enemy.y) < hitDist) {
                        bullets.splice(bi, 1);
                        enemy.health--;
                        if (enemy.health <= 0) {
                            const pts = enemy.type === 'boss' ? 500 : enemy.type === 'elite' ? 50 : 10;
                            score += pts * level;
                            playSound('explosion');
                            explode(enemy.x, enemy.y, enemy.type === 'boss' ? '#ff0000' : '#ff6b4a', enemy.type === 'boss' ? 25 : 10);
                            spawnPowerup(enemy.x, enemy.y);
                            enemies.splice(ei, 1);
                        } else {
                            explode(enemy.x, enemy.y, '#4a9eff', 4);
                        }
                        updateUI();
                    }
                });
            });

            // Enemy bullet-player collision
            if (!invincible && !powerups.shield.active) {
                enemyBullets.forEach((bullet, bi) => {
                    if (Math.abs(bullet.x - player.x) < 12 && Math.abs(bullet.y - player.y) < 15) {
                        enemyBullets.splice(bi, 1);
                        loseLife();
                    }
                });
            } else if (powerups.shield.active) {
                enemyBullets = enemyBullets.filter(b => {
                    if (Math.abs(b.x - player.x) < 26 && Math.abs(b.y - player.y) < 26) {
                        explode(b.x, b.y, '#4a9eff', 3);
                        return false;
                    }
                    return true;
                });
            }

            // Enemy-player collision
            enemies.forEach((enemy, ei) => {
                if (!invincible && Math.abs(enemy.x - player.x) < 20 && Math.abs(enemy.y - player.y) < 20) {
                    explode(enemy.x, enemy.y, '#ff6b4a', 12);
                    enemies.splice(ei, 1);
                    loseLife();
                }
            });

            // Powerup collection
            powerupItems.forEach((p, i) => {
                if (Math.abs(p.x - player.x) < 22 && Math.abs(p.y - player.y) < 22) {
                    playSound('powerup');
                    powerupItems.splice(i, 1);
                    if (p.type === 'life') {
                        lives = Math.min(lives + 1, 5);
                    } else {
                        powerups[p.type].active = true;
                        powerups[p.type].timer = 480;
                        document.getElementById(p.type + 'Badge').classList.add('active');
                    }
                    explode(p.x, p.y, p.color, 8);
                    updateUI();
                }
            });

            // Level complete - trigger warp!
            if (enemiesSpawned >= enemiesRequired && enemies.length === 0 && !waveTransition) {
                waveTransition = true;
                gameRunning = false;
                
                // Start warp transition
                setTimeout(() => {
                    startWarp(() => {
                        level++;
                        enemiesSpawned = 0;
                        enemiesRequired = 10 + level * 2;
                        changeEnvironment();
                        updateUI();
                        announceLevel();
                        
                        // Reset player position
                        player.x = canvas.width / 2;
                        player.y = 580;
                        
                        setTimeout(() => {
                            waveTransition = false;
                            spawnTimer = 60;
                            gameRunning = true;
                            loop();
                        }, 1500);
                    });
                }, 500);
            }
        }

        function loseLife() {
            lives--;
            playerExplode();
            updateUI();
            if (lives <= 0) gameOver();
            else { invincible = true; invincibleTimer = 90; }
        }

        function draw() {
            // Background color based on environment
            ctx.fillStyle = currentEnv.bg;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Nebula overlay
            if (currentEnv.nebulaColor) {
                ctx.fillStyle = currentEnv.nebulaColor;
                // Gradient nebula effect
                for (let i = 0; i < 3; i++) {
                    const x = (frameCount * 0.2 + i * 200) % (canvas.width + 200) - 100;
                    const y = 100 + i * 200;
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, 200);
                    gradient.addColorStop(0, currentEnv.nebulaColor);
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            }

            // Background objects (planets)
            bgObjects.forEach(obj => {
                if (obj.type === 'planet') drawPlanet(obj);
            });

            // Asteroids
            asteroids.forEach(a => drawAsteroid(a));

            // Stars with twinkle
            stars.forEach(star => {
                const twinkle = Math.sin(star.twinkle) * 0.3 + 0.7;
                const alpha = (0.4 + star.bright * 0.6) * twinkle;
                ctx.fillStyle = currentEnv.starColor;
                ctx.globalAlpha = alpha;
                ctx.fillRect(Math.floor(star.x), Math.floor(star.y), star.size, star.size);
            });
            ctx.globalAlpha = 1;

            // Particles
            particles.forEach(p => {
                ctx.globalAlpha = p.life / 35;
                ctx.fillStyle = p.color;
                ctx.fillRect(Math.floor(p.x) - p.size/2, Math.floor(p.y) - p.size/2, p.size, p.size);
            });
            ctx.globalAlpha = 1;

            // Power-ups
            powerupItems.forEach(p => drawPowerup(p));

            // Bullets (green laser bolts)
            ctx.fillStyle = '#4aff8c';
            bullets.forEach(b => {
                ctx.fillRect(Math.floor(b.x) - 1, Math.floor(b.y) - 5, 3, 10);
                // Glow
                ctx.fillStyle = 'rgba(74, 255, 140, 0.3)';
                ctx.fillRect(Math.floor(b.x) - 2, Math.floor(b.y) - 6, 5, 12);
                ctx.fillStyle = '#4aff8c';
            });
            
            // Enemy bullets (red)
            ctx.fillStyle = '#ff6b4a';
            enemyBullets.forEach(b => {
                ctx.fillRect(Math.floor(b.x) - 2, Math.floor(b.y) - 3, 4, 6);
            });

            // Enemies
            enemies.forEach(e => drawEnemy(e));

            // Player
            drawPlayer();
        }

        function loop() {
            if (!gameRunning) return;
            update();
            draw();
            gameLoop = requestAnimationFrame(loop);
        }

        function updateUI() {
            document.getElementById('scoreDisplay').textContent = String(score).padStart(6, '0');
            document.getElementById('levelDisplay').textContent = String(level).padStart(2, '0');
            document.getElementById('livesDisplay').textContent = '|'.repeat(Math.max(0, lives));
        }

        function startGame() {
            initAudio();
            score = 0; lives = 3; level = 1;
            enemies = []; bullets = []; enemyBullets = []; particles = []; powerupItems = [];
            player.x = canvas.width / 2; player.y = 580;
            invincible = false; waveTransition = false;
            enemiesSpawned = 0; enemiesRequired = 10; spawnTimer = 60;
            currentEnv = environments[0];
            
            Object.keys(powerups).forEach(k => {
                powerups[k].active = false; powerups[k].timer = 0;
                document.getElementById(k + 'Badge').classList.remove('active');
            });
            
            initStars();
            initBgObjects();
            updateUI();
            announceLevel();
            document.getElementById('startOverlay').classList.add('hidden');
            document.getElementById('gameOverOverlay').classList.add('hidden');
            
            setTimeout(() => { gameRunning = true; loop(); }, 1500);
        }

        function gameOver() {
            gameRunning = false;
            cancelAnimationFrame(gameLoop);
            document.getElementById('finalScore').textContent = String(score).padStart(6, '0');
            document.getElementById('finalLevel').textContent = String(level).padStart(2, '0');
            document.getElementById('gameOverOverlay').classList.remove('hidden');
            
            const lb = getLeaderboard();
            const isHigh = lb.length < 10 || score > (lb[lb.length - 1]?.score || 0);
            document.getElementById('newHighScore').style.display = isHigh && score > 0 ? 'block' : 'none';
            document.getElementById('nameInput').style.display = isHigh && score > 0 ? 'block' : 'none';
        }

        function getLeaderboard() {
            return JSON.parse(localStorage.getItem('k2-defense-lb') || '[]');
        }

        function saveScore(name, sc) {
            const lb = getLeaderboard();
            lb.push({ name: name || 'ANON', score: sc, level, date: Date.now() });
            lb.sort((a, b) => b.score - a.score);
            localStorage.setItem('k2-defense-lb', JSON.stringify(lb.slice(0, 10)));
            renderLeaderboard();
        }

        function renderLeaderboard() {
            const lb = getLeaderboard();
            const el = document.getElementById('leaderboardList');
            if (!lb.length) { el.innerHTML = '<div class="leaderboard-entry"><span class="rank">-</span><span class="name">NO SCORES</span><span class="entry-score">-</span></div>'; return; }
            el.innerHTML = lb.map((e, i) => {
                const rc = i === 0 ? 'gold' : i === 1 ? 'silver' : i === 2 ? 'bronze' : '';
                return `<div class="leaderboard-entry"><span class="rank ${rc}">${String(i+1).padStart(2,'0')}</span><span class="name">${e.name} <span style="color:#666">L${e.level||'?'}</span></span><span class="entry-score">${String(e.score).padStart(6,'0')}</span></div>`;
            }).join('');
        }

        // ===== CONTROLS =====
        document.addEventListener('keydown', e => { keys[e.key] = true; if (e.key === ' ' && gameRunning) { e.preventDefault(); shoot(); } });
        document.addEventListener('keyup', e => { keys[e.key] = false; });
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', () => {
            const inp = document.getElementById('nameInput');
            if (inp.style.display !== 'none' && inp.value) saveScore(inp.value.toUpperCase(), score);
            inp.value = '';
            startGame();
        });

        // Mobile controls
        ['up','down','left','right'].forEach(dir => {
            const btn = document.getElementById(dir + 'Btn');
            const key = 'Arrow' + dir.charAt(0).toUpperCase() + dir.slice(1);
            btn.addEventListener('touchstart', e => { e.preventDefault(); keys[key] = true; });
            btn.addEventListener('touchend', e => { e.preventDefault(); keys[key] = false; });
        });
        
        let fireInt;
        document.getElementById('fireBtn').addEventListener('touchstart', e => { e.preventDefault(); if (gameRunning) { shoot(); fireInt = setInterval(() => { if (gameRunning) shoot(); }, 120); }});
        document.getElementById('fireBtn').addEventListener('touchend', e => { e.preventDefault(); clearInterval(fireInt); });

        // Initialize
        initStars();
        initBgObjects();
        renderLeaderboard();
        draw();
    </script>
</body>
</html>
